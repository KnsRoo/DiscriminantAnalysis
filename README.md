# DiscriminantAnalysis
```python
import numpy as np 
import pandas as pd
from IPython.display import HTML
```
Numpy - это библиотека линейной алгебры. Умеет делать всякие вычисления.
Pandas - это библиотека для удобного хранения таблиц (фреймов). Умеет манипулировать табличными данными.
HTML - Это плагин для правильного отображения таблиц

Эта строчка означает, что мы берем данные из csv и превращаем в pandas фрейм.
```python
M1 = pd.read_csv('M1.csv')
```
Здесь мы пользуемся плагином HTML, чтобы корректно отобразить таблицу. index - false означает, что мы не будем выводить порядковые номера(индексы) столбцов.
```python
HTML(M1.to_html(index=False))
```
Это функция которая расчитывает среднее значение. 
**mean** - рассчитать среднее
**axis = 0** означает, что мы будем считать среднее в каждой строке.
**reshape** - перевернуть массив numpy из строки в столбец.
```python
def calcMean(X):
    mean = np.mean(X, axis = 0)
    return np.reshape(np.array(mean), (-1,1))
```
Здесь мы захватываем часть фрейма pandas, с помощью **iloc**. Проще говоря, обрезаем названия. Остальное превращаем в массив с помощью **to_numpy()**
```python
M1,M2 = M1.iloc[:,1:].to_numpy(), M2.iloc[:,1:].to_numpy()
```
Эта функция расчёта ковариационной матрицы. Принимает в себя матрицу, по которой нужно произвести расчет (исходная матрица) и вектор её средних значений.
**zeros** = создаем новую матрицу, с нулевыми значениями, размера длины вектора средних значений
Далее для каждой строки в матрице М считаем:
- из строки поэлементно вычитаем вектор средних значений.
- умножаем (**dot**) его на самого себя же, только транспонированного (**T**)
Возвращаем матрицу S, где каждый элемент поделен на количество столбцов в матрице М
```python
def getCovMatr(M, vec):
    s = np.zeros((len(vec),len(vec)))
    for row in M:
        s += (np.reshape(row,(-1,1)) - vec).dot((np.reshape(row,(-1,1)) - vec).T)
    return s/len(M)  
```
Функция получения объединенной ковариационной матрицы. Принимает два аргумента - оба массивы. Массив исходных матриц и массив их длин столбцов.
Получаем константу *constant*, суммируем аргументы args - это количество столбцов в исходных матрицах соответственно. Вычитаем из них количество матриц. Делим  1 на получившийся результат. Для каждой матрицы умножаем её самц на скаляр в виде количества её строк и суммируем (*summ*). Возвращаем сумму умноженную на константу.
```python
def getOCV(matrs,args):
    constant = 1/(np.sum(args) - len(matrs))
    summ = 0
    for index, row, in enumerate(matrs):
        summ +=args[index]*row
    return constant*summ
```
**linalng.inv** - функция расчет обратной матрицы
```python
ocvInv = np.linalg.inv(ocv)
```
**subtract** - Разность матриц
**dot** - умножение матриц
Умножаем обратную ковариационную матрицу на разность векторов средних значений строк исходных матриц
```python
A = np.dot(ocvInv,np.subtract(X1,X2))
```
Функция получения значений дискриминантной функции. Принимает в себя вектор дискриминантных множителей и исходную матрицу. Создаем пустой список, для каждой строки в исходной матрице, умножаем эту строку на вектор дискриминантных множителей. Возвращаем массив numpy
**array** - сделать массив numpy
```python
def getFuncValues(A,M):
    vec = []
    for row in M:
        vec.append(np.dot(row,A))
    return np.array(vec)
```
Взять коллонку с 0 индексом из фрейма pandas и превратить её в список.
```python
names = list(M0[M0.columns[0]])
```
Функция классификации. Принимает в себя вектор дискриминантных значений и среднее значение для каждой из групп. Для каждого значения в векторе дискриминантных значений, сначала сравнить его с соседом, если оно больше, то тогда, если оно же больше общего среднего дискриминации - определить в группу М1, иначе в М2, если меньше, то наоборот определить в группу М2, если оно больше среднего значения дискриминации, иначе  - в М1. Вернуть словарь имен и групп, в которые они определены со значением среднего. 
```python
def classificate(needle, Fm):
    res, index, Fms = {}, 0, np.mean(Fm)
    for index, Fi in enumerate(needle):
        if Fm[0] > Fm[1]:
            res[names[index]] = [Fi[0],'M1'] if (Fi[0] > Fms) else [Fi[0],'M2'] 
        else:
            res[names[index]] = [Fi[0],'M2'] if (Fi[0] > Fms) else [Fi[0],'M1']
    return res
```
Сделать датафрейм из словаря, с помощью **from_dict**. 
**orient** - ориентация
**columns** - имена колонок
```python
result = pd.DataFrame.from_dict(result, orient = "index", columns = ['F','Группа'])
```
