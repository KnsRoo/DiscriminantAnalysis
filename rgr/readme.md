# Описание кода

Начнём с импорта библиотек, здесь все понятно, import bla.bla.bla...
```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import HTML
```

Что такое **IPython.display** IPython.display можно почитать в предыдущем readme. Первое, что мы делаем это загрузку данных из файла. data - это pandas фрейм, для упрощения будем считать, что pandas фрейм это обычная таблица (двумерный массив). Загрузка данных осуществляется посредством функции **read_csv** библиотеки pandas, в качетсве аргумента передается имя файла.

Далее, переопределяем столбец t. К исходному столбцу t с помощью метода **apply** применяем функцию **str**. 

Зачем это нужно? Это нужно всего лишь для правильного отображения столбца t. Дело в том, что в исходном виде, столбцами являются t и y и отображаются вертикально. С целью экономии места, было решено отобразить их горизонтально, но при транспонировании (перемене строк и столбцов местами - **data.T**), строка t содержащие целые числа, превращается в вещественные и отображается неправильно (1.00, 2.00,3.00 и.т.д). Преобразование в строку, перед выводом позволяет отобразить столбец в исходном виде. Далее подобные манипуляции будут помечены комментарием *#для красоты*. 

Аргумент **header** со значением *False* позволяет не отображать индексы массива.

```python
data = pd.read_csv("data_series.csv")
data['t'] = data['t'].apply(str) #для красоты
HTML(data.T.to_html(header = False))
```

Далее идет построение гистограммы, здесь все просто вызываем метод **plot** у фрейма, за x обозначаем столбец t, за y столбец y. **figsize** - размер графика, **kind** - тип графика (*bar* - гистограмма), **title** - подпись графика.
Функции **set_xlabel, set_ylabel** устанавливают подписи к осям снизу и слева.

```python
plot = data.plot(x = 't', y = 'y', figsize=(16, 9), kind = "bar", title = "Прожиточный минимум в Архангельской области")
plot.set_xlabel("Период")
plot.set_ylabel("Прожиточный минимум")
```
Далее идет построение графика. Здесь все аналогично предыдущему, но перед выводом графика мы преобразуем данные обратно в целые числа (**apply**), чтобы график отображался правильно. Так как в данный момент t - строка, преобразуем ее в вещественные числа (**float**), в целые сразу не можем, т.к. интерпретатор выдаст ошибку. Затем округляем до целого (**round**) и преобразуем в целое (**int**). Да-да, все так серьёзно, потому что строгая типизация. По уже известной схеме строим график. **xlim** - задает границы оси x.

```python
data['t'] = data['t'].apply(lambda x: int(round(float(x)))) # для красоты
plot = data.plot(x = 't', y = 'y', figsize=(16, 9), grid = True, marker='o',title = "Исходный временной ряд", xlim = (0,len(data)+1)) # xlim - для красоты
plot.set_xlabel("Период")
plot.set_ylabel("Прожиточный минимум")
```

Про *TAU = 4*, здесь все понятно, прогноз будет осуществлять на 4 периода. Сразу перейдем к функции segment_slope. Эта функция реализует метод наименьших квадратов. В качестве аргументов принимает исходный массив данных ([X,Y]) и размер области определения. Не забываем, что изначально t у нас строковый столбец, поэтому преобразуем, его обратно в целое (**apply**). Даллее с помощью метода **iloc** обрежем наши столбцы. Таким образом в X попадет первые 5 значений столбца t, а в Y первые 5 значений столбца y. Сразу сосчитаем их математической ожидание с помощью функции **mean** библиотеки NumPy.
Внимательно посмотрим на формулу:
<center>
<img src="https://render.githubusercontent.com/render/math?math=b = \frac{\sum_{i=1}^{n} (x_i-\overline{x})(y_i-\overline{y})}{\sum_{i=1}^{n} (x_i-\overline{x})^2}">
</center>

Определим переменные n,d равные 0. Где n - числитель дроби, d - знаменатель дроби. И будем считать каждую сумму отдельно. Для числителя: **Из каждого элемента X вычитаем его математическое ожидание, из каждого элемента Y вычитаем его математическое ожидание, перемножаем результаты**. Для знаменателя: **Из каждого элемента X вычитаем его математическое ожидание. Возводим результат в квадрат** Присваиваем b результат деления. Присваиывем a значение согласно формуле:
<center>
<img src="https://render.githubusercontent.com/render/math?math=a = \overline{y} - b\overline{x}">
</center>

Возвращаем значения a,b

```python
def segment_slope(d, size = 5):
    d['t'] = d['t'].apply(int)
    X, Y = d.iloc[:size, 0], d.iloc[:size, 1]
    X_mean, Y_mean = np.mean(X), np.mean(Y)
    n,d = 0,0
    for i in range(len(X)):
        n += (X[i] - X_mean)*(Y[i] - Y_mean)
        d += (X[i] - X_mean)**2
    b = n / d
    a = Y_mean - b*X_mean
    return a,b
```

Перейдем к линейной функции, здесь все просто: Функция принимает аргументы a,b,t, и возвращаем выражение $$y = a+bt$$

```python
linear = lambda a,b,t: a+b*t
```

Перейдем к функция расчёта трендовых значений на предыдущий период для моделей Хольта-Уинтерса и Тела-Вейджа. Здесь ничего сложного. В качестве входных аргументов передается сам массив значений y, а также массив yr, здесь yr это массив y к которому была применена функция линейного преобразования, описаная выше. В качестве a,b  использовались значения, полученные по методу МНК (об это будет написано ниже, при непосредственном построении модели). Всего будет задействовано 8 первых элементов массивов. Функции будут возвращать массив из 4 элементов. Расчёт производится по формулам:

<center>
<img src="https://render.githubusercontent.com/render/math?math=F_{i} = 0,5(\frac{y_i}{\hat{y}_i}+\frac{y_{i+4}}{\hat{y}_{i+4}}) \quad i \in [0,4]">
<img src="https://render.githubusercontent.com/render/math?math=W_{i} = 0,5(y_i-\hat{y}_i+y_{i+4}-\hat{y}_{i+4}) \quad i \in [0,4]">
</center>
для моделей Хольта-Уинтерса и Тела-Вейджа соотвествтенно.
Для модели Хольта-Уинтерса: **Отношение каждого элемента массива Y к соотвествующему элементу массива YR складываем с отношением каждого отстоящего на 4 индекса элемента массива Y к каждому отстоящему на 4 индекса элементу YR**
Для модели Телла-Уинтерса: **Разность каждого элемента массива Y к соотвествующему элементу массива YR складываем с разностью каждого отстоящего на 4 индекса элемента массива Y к каждому отстоящему на 4 индекса элементу YR**

Если данное объяснение кажется сложным, можно воспользоваться схемой:

<img width = "1000px" src = "https://d.radikal.ru/d13/2105/91/2e5dea4e9682.png">

Схема построена для модели Хольта-Уинтерса, для модели Тела-Вейджа знак деленнния, заменяется на знак разности

```python
HW_start_values = lambda y, yr: [0.5*(y[i]/yr[i]+y[i+4]/yr[i+4]) for i in range(4)]
TW_start_values = lambda y, yr: [0.5*(y[i]-yr[i]+y[i+4]-yr[i+4]) for i in range(4)]
```

Функция расчета коэффицента детерминации. Все просто. Весь расчет идет в соответствии с формулами:

<center>
<img src="https://render.githubusercontent.com/render/math?math=R^2 = 1- \frac{SS_{res}}{SS_{tot}}">

<img src="https://render.githubusercontent.com/render/math?math=SS_{res} = \sum_{i=1}^{n} (y_i - \hat{y_{i}})^2">

<img src="https://render.githubusercontent.com/render/math?math=SS_{tot} = \sum_{i=1}^{n} (y_i - \overline{y})^2">

</center>

На вход подается исходный массив Y и массив сосчитанный по модели значений YTH. Считаем математическое ожидание Y. Для числителя: Для каждого элемента Y и YTH соответственно, возводим в квадрат разность между исходным и и посчитанным значением и суммируем. Для знаемнателя: Для каждого элемента Y возводим в квадрат разность его самого и его математического ожидания и суммируем. Возвращаем разность единицы и отношения SSres к SStot. перед этим переводим в проценты, округляем до 2 знаков **round**

```python
def r_squared(Y,YTH):
    Y_mean = np.mean(Y)
    SS_res = sum([(Y[i] - YTH[i])**2 for i in range(len(Y))])
    SS_tot = sum([(item - Y_mean)**2 for item in Y])
    coef = 1-(SS_res/SS_tot)
    return "{}%".format(round(coef*100,2))
```